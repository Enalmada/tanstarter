/**
 * TEMPORARILY COMMENTED OUT
 */
/*
/**
 * Base Service Pattern
 *
 * Combines repository pattern with authorization checks
 *
 * Steps to create a new entity service:
 * 1. Define your schema in db/schema.ts
 * 2. Add entity type to Subjects in auth/casl.ts
 * 3. Add permissions for the entity in createAbility() in auth/casl.ts
 * 4. Create a service following the task-service.ts pattern
 */

import type { PgTableWithColumns } from "drizzle-orm/pg-core";
import type { SubjectType } from "../access/ability";
import { accessCheck } from "../access/check";
import { createDrizzleRepository } from "../db/DrizzleOrm";
import type { User } from "../db/schema";

import { type StringSchema, object, safeParse, string } from "valibot";
import { getAuthSession } from "~/server/auth/auth";

export const idSchema = object({
	id: string("ID is required") as StringSchema<string>,
});

export function validateId(input: unknown): string {
	if (!input || typeof input !== "object") {
		throw new Error("Invalid ID");
	}

	if (!("id" in input)) {
		throw new Error("Invalid ID");
	}

	if (typeof input.id !== "string") {
		throw new Error("Invalid ID");
	}

	if (input.id.length === 0) {
		throw new Error("ID cannot be empty");
	}

	const result = safeParse(idSchema, input);
	if (!result.success) {
		const errorMessage = result.issues[0]?.message;
		throw new Error(errorMessage || "Invalid ID");
	}
	return result.output.id;
}

// Helper function to get authenticated user
export async function getAuthenticatedUser(): Promise<User> {
	const { user } = await getAuthSession();
	if (!user) {
		throw new Error("Unauthorized");
	}
	return user as User;
}

export interface BaseEntity {
	id: string;
	createdById?: string | null;
	createdAt: Date;
	updatedById?: string | null;
	updatedAt?: Date | null;
	version: number;
	// biome-ignore lint/suspicious/noExplicitAny: <explanation>
	[key: string]: any;
}

export function createBaseService<
	// TEntity extends { [key: string]: any },
	// TInput extends { [key: string]: any },
	// TODO better typing
	TEntity extends BaseEntity,
	TInput extends Partial<BaseEntity>,
>(
	// biome-ignore lint/suspicious/noExplicitAny: <explanation>
	table: PgTableWithColumns<any>,
	/*
	// TODO - make this more specific than any
	table: PgTableWithColumns<{
			name: string;
			schema: unknown;
			columns: Record<string, unknown>;
		}>
		*/
	subject: SubjectType,
) {
	const repository = createDrizzleRepository<TEntity, TInput>(table);

	return {
		async findFirst(criteria: Partial<TEntity>, user?: unknown) {
			const authenticatedUser = await getAuthenticatedUser();
			accessCheck(authenticatedUser, "read", subject, criteria);
			return repository.findFirst(criteria);
		},

		async findMany(criteria: Partial<TEntity>, user?: unknown) {
			const authenticatedUser = await getAuthenticatedUser();
			accessCheck(authenticatedUser, "list", subject, criteria);
			return repository.findMany(criteria);
		},

		async findPage(criteria: Partial<TEntity>, user?: unknown) {
			const authenticatedUser = await getAuthenticatedUser();
			accessCheck(authenticatedUser, "list", subject, criteria);
			return repository.findPage(criteria);
		},

		async create(data: TInput, user?: unknown) {
			const authenticatedUser = await getAuthenticatedUser();

			// Add auditing entries
			// TODO: some of these like versiion for optimistic locking
			// still need to be added to the schema
			const createWith = {
				...data,
				createdAt: new Date(),
				createdById: authenticatedUser?.id,
				updatedAt: new Date(),
				updatedById: authenticatedUser?.id,
				version: 1,
			};

			accessCheck(authenticatedUser, "create", subject, createWith);
			return repository.create(createWith);
		},

		async update(id: string, data: Partial<TInput>, user?: unknown) {
			const authenticatedUser = await getAuthenticatedUser();
			const existing = await repository.findFirst({ id } as Partial<TEntity>);
			if (!existing) {
				throw new Error("Not found");
			}

			if (existing.version !== data.version) {
				// TODO notify user that entity has changed in another tab, device, or session.
				throw new Error(
					`${subject} has changed since loading.  Please reload and try again.`,
				);
			}

			accessCheck(authenticatedUser, "update", subject, existing);

			const updateWith = {
				...data,
				updatedAt: new Date(),
				updatedById: authenticatedUser?.id,
				version: existing.version + 1,
			};

			return repository.update(id, data);
		},

		async delete(id: string, user?: unknown) {
			const authenticatedUser = await getAuthenticatedUser();
			const existing = await repository.findFirst({ id } as Partial<TEntity>);
			if (!existing) {
				throw new Error("Not found");
			}
			accessCheck(authenticatedUser, "delete", subject, existing);
			return repository.delete(id);
		},
	};
}

